package piping

import (
	"fmt"
	"l2met/store"
	"l2met/utils"
)

//The randomOutlet verifys that the buckets that it recives were generated
//by the random source it is a associated with (by passing it's testList to 
//the constructor) it sends a bool over the success channel every time it
//recives and process a bucket saying wether it was a valid bucket that was
//generated by the RandomSource. When it has recived all of the buckets that
//were generated it sends a bool over the done channel.
type RandomOutlet struct {
	receiver *SingleReciver
	testList map[string]*store.Bucket
	success  chan bool
	done     chan bool
	control  chan bool
	expected int
}

//Returns a new RandomOutlet taking: expected (the number of items generated by
//the randomSource)
//testlist: a map from the randomSource mapping all of the bucket keys to the
//bucket
//input: a channel feeding the outlet buckets.
func NewRandomOutlet(expected int, testList map[string]*store.Bucket, input chan *store.Bucket) (t *RandomOutlet) {
	t = &RandomOutlet{
		receiver: NewSingleReciver(input),
		testList: testList,
		success:  make(chan bool, 1),
		control:  make(chan bool),
		done:     make(chan bool),
		expected: expected}
	return t
}

func (t *RandomOutlet) Start() {
	go t.receiver.Start()
	go t.runCheckBuckets()
}

func (t *RandomOutlet) Stop() {
	t.control <- true
}

//gets a channel that will be triggered when all of the buckets have been found
func (t *RandomOutlet) Done() chan bool {
	return t.done
}

func (t *RandomOutlet) runCheckBuckets() {
	found := 0
	for {
		select {

		case <-t.control:
			return

		case next := <-t.receiver.input:
			utils.MeasureI("randomOutlet.input.channel.length", int64(len(t.receiver.input)))
			//nice place for benchmark
			//check to see if the bucket is the same as the one just sent
			found++
			other, hok := t.testList[next.Key.Token]

			if !hok {
				print("Bucket Not found in list\n")
				t.success <- false

			} else {

				if !Compare(next, other) {
					print("Buckets values wrong\n")
					t.success <- false
				}

				t.success <- true
				println(found)
			}

			if found == t.expected {
			}

		}

	}
}

//Compares two buckets and returns bool saying if they are equal and some 
//diagnostics if they are differnt.
func Compare(b, other *store.Bucket) bool {
	b.Get()
	other.Get()
	if CompareFloatSlice(b.Vals, other.Vals) {
		fmt.Printf("values munged\n")
		fmt.Printf("expected:%v \n got:%v", b.Vals, other.Vals)
	}
	if b.Key.Name == other.Key.Name &&
		b.Key.Source == other.Key.Source &&
		b.Key.Token == other.Key.Token {
		return true
	}
	fmt.Printf("Bkey munged\n")
	fmt.Printf("expect:%s, got:%s", b.String(), other.String())
	return false
}

func CompareFloatSlice(a, b []float64) bool {
	if len(a) != len(b) {
		return false
	}
	for i, c := range a {
		if c != b[i] {
			return false
		}
	}
	return true
}

//Gets a channel that ticks every time a bucket is recived with a bool 
//telling wether the bucket was valid or not
func (t *RandomOutlet) GetSuccessChan() (suc chan bool) {
	return t.success
}
